<!doctype html><html lang=zh-cn><head><meta charset=utf-8><title>PostgreSQL 表分区使用详解 - 磊磊落落</title><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=keywords content="PostgreSQL,表分区"><meta name=description content="本文依据官方 PostgreSQL 16 文档来介绍为什么使用表分区？以及表分区的具体使用方法。"><meta name=author content="磊磊落落"><meta name=generator content="Hugo 0.81.0"><link rel=stylesheet href=https://olzhy.github.io/css/bootstrap.min.css><link rel=stylesheet href=https://olzhy.github.io/css/themify-icons.css><link rel=stylesheet href=https://olzhy.github.io/css/larry-custom.css><link rel=stylesheet href=https://olzhy.github.io/scss/style.min.css media=screen><link rel="shortcut icon" href=https://olzhy.github.io/images/favicon.png type=image/x-icon><link rel=icon href=https://olzhy.github.io/images/favicon.png type=image/x-icon><script>var _hmt=_hmt||[];(function(){var a=document.createElement("script"),b;a.src="https://hm.baidu.com/hm.js?526723b767317055572c85bdb445353c",b=document.getElementsByTagName("script")[0],b.parentNode.insertBefore(a,b)})()</script></head><body><header class="fixed-top navigation"><div class=container><nav class="navbar navbar-expand-lg navbar-light bg-transparent"><a class=navbar-brand href=https://olzhy.github.io/>磊磊落落</a>
<button class="navbar-toggler border-0" type=button data-toggle=collapse data-target=#navigation>
<i class="ti-menu h3"></i></button><div class="collapse navbar-collapse text-center" id=navigation><ul class="navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=https://olzhy.github.io/></a></li><li class=nav-item><a class=nav-link href=https://olzhy.github.io/categories/%E9%9A%8F%E7%AC%94/>随笔</a></li><li class=nav-item><a class=nav-link href=https://olzhy.github.io/categories/%E8%AF%BB%E4%B9%A6/>读书</a></li><li class=nav-item><a class=nav-link href=https://olzhy.github.io/categories/%E8%A7%82%E5%BD%B1/>观影</a></li><li class=nav-item><a class=nav-link href=https://olzhy.github.io/categories/%E7%BB%83%E5%AD%97/>练字</a></li><li class=nav-item><a class=nav-link href=https://olzhy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/>计算机</a></li></ul><div class=search><button id=searchOpen class=search-btn><i class=ti-search></i></button><div class=search-wrapper><form action=https://olzhy.github.io//search class=h-100><input class="search-box px-4" id=search-query name=s type=search placeholder=键入关键字后回车...></form><button id=searchClose class=search-close><i class="ti-close text-dark"></i></button></div></div></div></nav></div></header><div class="py-5 d-none d-lg-block"></div><section class=section><div class=container><div class=row><div class="col-lg-8 mx-auto block shadow mb-5"><h1>PostgreSQL 表分区使用详解</h1><div class="mb-3 post-meta">2023年10月21日
<a href=/categories/%e8%ae%a1%e7%ae%97%e6%9c%ba>计算机</a></div><div class="content mb-5"><p>表分区指的是将逻辑上的一个大表分割为物理上的一个个小块，使用表分区可以带来性能上的提升与存储上的优化。PostgreSQL 支持基础的表分区功能。本文将依据官方 PostgreSQL 16 文档来介绍为什么使用表分区？以及表分区的具体使用方法。</p><p>为什么要使用表分区呢？因为表分区可以带来诸多好处，罗列如下：</p><ul><li><p>表分区对于特定的数据分布场景（如：频繁访问的行位于单个分区或少数几个分区）会有极大的性能提升；</p></li><li><p>当查询或更新访问的是单个分区的大部分数据时，使用该分区的顺序扫描会比使用索引（使用索引需要对全表进行随机访问读取）更加高效；</p></li><li><p>如果分区设计的得当，则可以通过新增或移除分区来完成批量加载和批量删除。使用<code>DROP TABLE</code>或<code>ALTER TABLE DETACH PARTITION</code>删除单个分区要比批量操作快得多，同时这些命令还完全避免了批量<code>DELETE</code>造成的<code>VACUUM</code>开销；</p></li><li><p>不常使用的数据可以迁移到慢一些但便宜很多的存储介质上。</p></li></ul><p>什么时候使用表分区呢？官方的建议是当表的大小超过了数据库服务器的物理内存大小（内存，非硬盘）时，进行分区会带来好处。</p><p>PostgreSQL 中划分分区的方式有哪些呢？罗列如下：</p><ul><li><p>区间划分</p><p>用主键列或几个列的组合将表划分为一段段的区间，且区间之间没有重叠。如业务上可能会使用日期字段进行分区，也可能会使用数值 ID 进行分区，且分区后的区间应保持左闭右开，如：<code>[1, 10), [10, 20), [20, ...), ...</code>。</p></li><li><p>列表划分</p><p>显式列出哪些键值属于哪块分区。</p></li><li><p>哈希划分</p><p>将分区键的哈希值进行模除后，用余数来标识落入哪个分区。</p></li></ul><p>此外，若如上分区方式不满足要求，则可以使用继承和<code>UNION ALL</code>视图等替代方法，这些方法虽然可用，但没有性能优势。</p><h2 id=1-声明式分区>1 声明式分区</h2><p>PostgreSQL 允许以声明的方式进行表分区，被分割的表称为分区表，声明语句包括上面列出的分区方法和一组用作分区键的列或表达式。</p><p>分区表本身是一个「虚拟」表，没有自己的存储；存储属于分区，这些分区是与分区表关联的普通表。</p><p>对分区表进行插入时，各行会根据分区键路由到对应的分区。更新分区键也可能会导致数据落入与之前不同的分区。</p><p>分区本身也可以定义为分区表，从而由分区衍生出了子分区。所有分区须与分区表具有相同的列，但分区可能具有自己的索引、约束和默认值，且可能与其它分区的索引、约束和默认值不同。</p><p>无法将常规表转换为分区表，反之亦然。但是，可以将现有的常规表或分区表添加为分区表的分区，或者从分区表中删除分区，而将其转换为独立表，这可以简化和加快许多维护过程。</p><p>分区也可以是外部表，但需要保证外部表满足分区规则。此外，还有一些其它限制。</p><h3 id=11-创建分区>1.1 创建分区</h3><p>假定我们在为大型日志业务构建数据库表，其表结构可能是如下这个样子：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> log_history (
    id              int <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
    content         text,
    logdate         date <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>
);
</code></pre></div><p>假定日志的查询常常限定在一年里，越近的数据查询频率越高，越远的数据查询越少。这种情况很适合使用分区来实现对性能的要求，下面即使用声明的方式来对该表进行分区。</p><p>步骤如下：</p><p><strong>创建分区表</strong></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#75715e>-- 这里使用了区间划分方式
</span><span style=color:#75715e></span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> log_history (
    id              int <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
    content         text,
    logdate         date <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>
) PARTITION <span style=color:#66d9ef>BY</span> RANGE (logdate);
</code></pre></div><p><strong>创建分区</strong></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#75715e>-- 针对 2010 至 2022 年的数据，一年存一个分区，区间左闭右开
</span><span style=color:#75715e></span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> log_history_2010 PARTITION <span style=color:#66d9ef>OF</span> log_history
    <span style=color:#66d9ef>FOR</span> <span style=color:#66d9ef>VALUES</span> <span style=color:#66d9ef>FROM</span> (<span style=color:#e6db74>&#39;2010-01-01&#39;</span>) <span style=color:#66d9ef>TO</span> (<span style=color:#e6db74>&#39;2011-01-01&#39;</span>);

<span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> log_history_2011 PARTITION <span style=color:#66d9ef>OF</span> log_history
    <span style=color:#66d9ef>FOR</span> <span style=color:#66d9ef>VALUES</span> <span style=color:#66d9ef>FROM</span> (<span style=color:#e6db74>&#39;2011-01-01&#39;</span>) <span style=color:#66d9ef>TO</span> (<span style=color:#e6db74>&#39;2012-01-01&#39;</span>);

<span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> log_history_2012 PARTITION <span style=color:#66d9ef>OF</span> log_history
    <span style=color:#66d9ef>FOR</span> <span style=color:#66d9ef>VALUES</span> <span style=color:#66d9ef>FROM</span> (<span style=color:#e6db74>&#39;2012-01-01&#39;</span>) <span style=color:#66d9ef>TO</span> (<span style=color:#e6db74>&#39;2013-01-01&#39;</span>);

...

<span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> log_history_2022 PARTITION <span style=color:#66d9ef>OF</span> log_history
    <span style=color:#66d9ef>FOR</span> <span style=color:#66d9ef>VALUES</span> <span style=color:#66d9ef>FROM</span> (<span style=color:#e6db74>&#39;2022-01-01&#39;</span>) <span style=color:#66d9ef>TO</span> (<span style=color:#e6db74>&#39;2023-01-01&#39;</span>);
</code></pre></div><p>2023 年的数据比较新，使用频率比较高，所以若想对分区<code>log_history_2023</code>再划分子分区，可以这样做：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> log_history_2023 PARTITION <span style=color:#66d9ef>OF</span> log_history
    <span style=color:#66d9ef>FOR</span> <span style=color:#66d9ef>VALUES</span> <span style=color:#66d9ef>FROM</span> (<span style=color:#e6db74>&#39;2023-01-01&#39;</span>) <span style=color:#66d9ef>TO</span> (<span style=color:#e6db74>&#39;2024-01-01&#39;</span>)
    PARTITION <span style=color:#66d9ef>BY</span> RANGE (logdate);
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#75715e>-- 按年划分后，再按月划分数据
</span><span style=color:#75715e></span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> log_history_2023_01 PARTITION <span style=color:#66d9ef>OF</span> log_history_2023
    <span style=color:#66d9ef>FOR</span> <span style=color:#66d9ef>VALUES</span> <span style=color:#66d9ef>FROM</span> (<span style=color:#e6db74>&#39;2023-01-01&#39;</span>) <span style=color:#66d9ef>TO</span> (<span style=color:#e6db74>&#39;2023-02-01&#39;</span>);

<span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> log_history_2023_02 PARTITION <span style=color:#66d9ef>OF</span> log_history_2023
    <span style=color:#66d9ef>FOR</span> <span style=color:#66d9ef>VALUES</span> <span style=color:#66d9ef>FROM</span> (<span style=color:#e6db74>&#39;2023-02-01&#39;</span>) <span style=color:#66d9ef>TO</span> (<span style=color:#e6db74>&#39;2023-03-01&#39;</span>);

<span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> log_history_2023_03 PARTITION <span style=color:#66d9ef>OF</span> log_history_2023
    <span style=color:#66d9ef>FOR</span> <span style=color:#66d9ef>VALUES</span> <span style=color:#66d9ef>FROM</span> (<span style=color:#e6db74>&#39;2023-03-01&#39;</span>) <span style=color:#66d9ef>TO</span> (<span style=color:#e6db74>&#39;2023-04-01&#39;</span>);

...

<span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> log_history_2023_12 PARTITION <span style=color:#66d9ef>OF</span> log_history_2023
    <span style=color:#66d9ef>FOR</span> <span style=color:#66d9ef>VALUES</span> <span style=color:#66d9ef>FROM</span> (<span style=color:#e6db74>&#39;2023-12-01&#39;</span>) <span style=color:#66d9ef>TO</span> (<span style=color:#e6db74>&#39;2024-01-01&#39;</span>);
</code></pre></div><p>所有分区建好后，可以在分区表创建索引，这会自动在每个分区上创建匹配的索引。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>INDEX</span> <span style=color:#66d9ef>ON</span> log_history (logdate);
</code></pre></div><p><em><strong>注意：确保 <code>postgresql.conf</code> 配置文件中未禁用 <code>enable_partition_pruning</code> 配置参数。否则，查询将不会根据需要进行优化。</strong></em></p><h3 id=12-分区维护>1.2 分区维护</h3><p>通常，最初定义表时建立的一组分区并不是一成不变的，一般后面会经常动态的增删分区。如定期删除旧数据分区、新增新数据分区。这时，分区的优点就会凸显，即操作分区结构会比物理的移动数据省事。</p><p>删除旧数据最简单的方法是删除不再需要的分区：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#66d9ef>DROP</span> <span style=color:#66d9ef>TABLE</span> log_history_2010;
</code></pre></div><p>因为该种方式不会单独一条一条的删除记录，可以非常快速地一次性删除数百万条记录。但需注意，上述命令须从父表上获取<code>ACCESS EXCLUSIVE</code>锁。</p><p>通常更推荐的做法是从分区表中删除分区，但保留将分区作为普通表，以及对其进行访问的权限。这有两种形式：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> log_history DETACH PARTITION log_history_2010;
<span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> log_history DETACH PARTITION log_history_2010 CONCURRENTLY;
</code></pre></div><p>第一种形式需要父表上的<code>ACCESS EXCLUSIVE</code>锁；第二种形式（添加<code>CONCURRENTLY</code>限定符允许分离操作）仅需要父表上的<code>SHARE UPDATE EXCLUSIVE</code>锁。</p><p>这样，即可以在数据被删除之前，对数据做一些清理前操作。如使用<code>COPY</code>、<code>pg_dump</code>等命令进行数据备份等。</p><p>同样，也可以为即将到来的新数据添加新分区：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> log_history_2024 PARTITION <span style=color:#66d9ef>OF</span> log_history
    <span style=color:#66d9ef>FOR</span> <span style=color:#66d9ef>VALUES</span> <span style=color:#66d9ef>FROM</span> (<span style=color:#e6db74>&#39;2024-01-01&#39;</span>) <span style=color:#66d9ef>TO</span> (<span style=color:#e6db74>&#39;2025-01-01&#39;</span>);
</code></pre></div><p>另一种推荐的方案是：在分区结构之外创建新表，后续再将其附加为分区表的分区。这可以保证新数据插入分区表之前已进行过加载、检查和数据转换。而且，<code>ATTACH PARTITION</code>操作只需要分区表上的<code>SHARE UPDATE EXCLUSIVE</code>锁，而不是<code>CREATE TABLE ... PARTITION OF</code>需要的<code>ACCESS EXCLUSIVE</code>锁，所以对分区表的并发操作更加友好。</p><p>创建新表，然后将其附加为分区表的分区示例如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#75715e>-- CREATE TABLE ... LIKE 命令可以避免繁琐地重复父表的定义
</span><span style=color:#75715e></span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> log_history_2024
  (<span style=color:#66d9ef>LIKE</span> log_history <span style=color:#66d9ef>INCLUDING</span> <span style=color:#66d9ef>DEFAULTS</span> <span style=color:#66d9ef>INCLUDING</span> <span style=color:#66d9ef>CONSTRAINTS</span>);

<span style=color:#75715e>-- 在运行 ATTACH PARTITION 命令之前
</span><span style=color:#75715e>-- 建议在要附加的表上创建一个与预期分区约束一致的 CHECK 约束
</span><span style=color:#75715e>-- 这样，系统将能够跳过扫描
</span><span style=color:#75715e>-- 否则，ATTACH PARTITION 时，将会对该分区加 ACCESS EXCLUSIVE 锁来进行扫描
</span><span style=color:#75715e></span><span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> log_history_2024 <span style=color:#66d9ef>ADD</span> <span style=color:#66d9ef>CONSTRAINT</span> logdate_check
   <span style=color:#66d9ef>CHECK</span> ( logdate <span style=color:#f92672>&gt;=</span> DATE <span style=color:#e6db74>&#39;2024-01-01&#39;</span> <span style=color:#66d9ef>AND</span> logdate <span style=color:#f92672>&lt;</span> DATE <span style=color:#e6db74>&#39;2025-01-01&#39;</span>);

<span style=color:#75715e>-- 然后进行 COPY 等数据准备工作
</span><span style=color:#75715e></span><span style=color:#960050;background-color:#1e0010>\</span><span style=color:#66d9ef>copy</span> log_history_2024 <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;log_history_2024&#39;</span>

<span style=color:#75715e>-- 进行 PARTITION ATTACH
</span><span style=color:#75715e></span><span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> log_history ATTACH PARTITION log_history_2024
    <span style=color:#66d9ef>FOR</span> <span style=color:#66d9ef>VALUES</span> <span style=color:#66d9ef>FROM</span> (<span style=color:#e6db74>&#39;2024-01-01&#39;</span>) <span style=color:#66d9ef>TO</span> (<span style=color:#e6db74>&#39;2025-01-01&#39;</span>);

<span style=color:#75715e>-- ATTACH PARTITION 完成后删除冗余的 CHECK 约束
</span><span style=color:#75715e></span><span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> log_history_2024 <span style=color:#66d9ef>DROP</span> <span style=color:#66d9ef>CONSTRAINT</span> logdate_check;
</code></pre></div><p>如果附加的表本身是分区表，则其每个子分区都将被递归锁定和扫描，直到找到合适的<code>CHECK</code>约束或到达叶子分区。</p><p>同样，如果分区表具有默认分区，则建议在默认分区上创建一个<code>CHECK</code>约束，以排除要附加分区的约束。如果不这样做，<code>ATTACH PARTITION</code>时会扫描默认分区以查看是否与要附加的分区有重叠的数据（此操作将在默认分区上加<code>ACCESS EXCLUSIVE</code>锁来执行）。如果默认分区本身是一个分区表，跟上面一样，其每个子分区都将以与附加表相同的方式进行递归检查。</p><p>前面也演示过，可以直接在分区表上创建索引，其会自动应用于所有分区。这很方便，因为不仅现有分区会被索引，而且将来创建的任何分区也会被索引。有一个限制是，在创建此类分区索引时，不能使用<code>CONCURRENTLY</code>限定符。为了避免长时间的锁定时间，可以先对分区表使用<code>CREATE INDEX ON ONLY</code>命令来创建索引，该索引会被标记为无效，不会自动应用到分区上。然后使用<code>CONCURRENTLY</code>单独创建分区上的索引，然后使用<code>ALTER INDEX</code>将分区上的索引附加到父分区上的索引，待将所有分区的索引附加到父索引后，父索引将自动标记为有效。</p><p>例如：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>INDEX</span> log_history_id_idx <span style=color:#66d9ef>ON</span> <span style=color:#66d9ef>ONLY</span> log_history (id);

<span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>INDEX</span> log_history_2024_id_idx
    <span style=color:#66d9ef>ON</span> log_history_2024 (id);

<span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>INDEX</span> log_history_id_idx
    ATTACH PARTITION log_history_2024_id_idx;

...
</code></pre></div><p>此技术也同样适用于<code>UNIQUE</code>和<code>PRIMARY KEY</code>约束。</p><p>例如：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> <span style=color:#66d9ef>ONLY</span> log_history <span style=color:#66d9ef>ADD</span> <span style=color:#66d9ef>UNIQUE</span> (id, logdate);

<span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> log_history_2024 <span style=color:#66d9ef>ADD</span> <span style=color:#66d9ef>UNIQUE</span> (id, logdate);

<span style=color:#75715e>-- 索引是在创建约束时隐式创建的
</span><span style=color:#75715e></span><span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>INDEX</span> log_history_id_logdate_key
    ATTACH PARTITION log_history_2024_id_logdate_key;

...
</code></pre></div><h2 id=2-继承式分区>2 继承式分区</h2><blockquote><p>参考资料</p><p>[1] <a href=https://www.postgresql.org/docs/16/ddl-partitioning.html>5.11 Table Partitioning - Data Definition | PostgreSQL 16 Documentation - www.postgresql.org</a></p><p>[2] <a href=https://www.cnblogs.com/haha029/p/15718827.html>PostgreSQL 表分区 | 博客园 - www.cnblogs.com</a></p></blockquote></div><div class=content-footer><div class=post-tags><a href=/tags/postgresql/>#PostgreSQL</a></div></div></div><div class="col-lg-8 mx-auto block shadow"><h3>相关文章</h3><ul><li><a href=/posts/postgres-ddl.html>PostgreSQL 数据定义相关知识总结</a></li><li><a href=/posts/postgres-table-inheritance.html>PostgreSQL 表继承使用详解</a></li><li><a href=/posts/postgres-tablespaces.html>PostgreSQL 表空间使用详解</a></li><li><a href=/posts/postgres-foreign-data-wrappers.html>PostgreSQL 外部数据包装器 postgres_fdw 使用详解</a></li><li><a href=/posts/azure-postgres.html>Azure Database for PostgreSQL 学习总结</a></li></ul></div><div class="col-lg-8 mx-auto block shadow"><div align=center><table><tr><b style=color:#e8505b>创作不易，如果我的文章确实帮助到了您，请我喝一杯饮料就是一种莫大的支持！<a href=/thanks>Thanks!</a></b></tr><tr><td align=center><b>微信</b></td><td></td><td></td><td></td><td></td><td align=center><b>支付宝</b></td></tr><tr><td><img src=/static/images/self/wechat.png style=width:120px;height:120px></td><td></td><td></td><td></td><td></td><td><img src=/static/images/self/alipay.png style=width:120px;height:120px></td></tr></table></div></div><script src=https://utteranc.es/client.js repo=olzhy/olzhy.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></div></section><footer class="py-4 bg-lights border-top"><div class=container><div class="row justify-content-between text-center align-items-center"><div class="col-lg-4 text-center text-lg-left mb-4 mb-lg-0"></div><div class="col-lg-4 text-center mb-4 mb-lg-0"><ul class="list-inline mb-0"><li class=list-inline-item><a class="text-dark d-block p-2" href=https://olzhy.github.io/leetcode-golang-implementations>LeetCode</a></li><li class=list-inline-item><a class="text-dark d-block p-2" href=https://olzhy.github.io/about>关于本站</a></li><li class=list-inline-item><a class="text-dark d-block p-2" href=https://olzhy.github.io/links>友情链接</a></li></ul></div><div class="col-lg-4 text-lg-right text-center mb-4 mb-lg-0"><ul class="list-inline social-icon mb-0"><li class=list-inline-item><a title=文章归档 href=/archives/><i class=ti-archive></i></a></li><li class=list-inline-item><a title=文章标签 href=/tags/><i class=ti-tag></i></a></li><li class=list-inline-item><a title="我的 GitHub" href=https://github.com/olzhy><i class=ti-github></i></a></li><li class=list-inline-item><a title="网站 RSS" href=/index.xml><i class=ti-rss></i></a></li></ul></div></div><div class="text-center mt-4"><span>Made with <a href=https://gohugo.io/>Hugo</a> | Theme <a href=https://github.com/themefisher/northendlab-hugo>NorthendLab</a> | <a href=https://beian.miit.gov.cn>辽ICP备2022012085号-1</a> | Copyright © 2017-2023</span></div></div></footer><script>var indexURL="https://olzhy.github.io/index.json"</script><script src=https://olzhy.github.io/js/jquery.min.js></script><script src=https://olzhy.github.io/js/bootstrap.min.js></script><script src=https://olzhy.github.io/js/fuse.min.js></script><script src=https://olzhy.github.io/js/mark.js></script><script src=https://olzhy.github.io/js/search.js></script><script src=https://olzhy.github.io/js/script.min.js></script></body></html>